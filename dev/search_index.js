var documenterSearchIndex = {"docs":
[{"location":"#GraphsMatching.jl:-matching-algorithms-for-Graphs.jl","page":"Getting started","title":"GraphsMatching.jl: matching algorithms for Graphs.jl","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"This is the documentation page for GraphsMatching. In all documentation examples, we assume GraphsMatching has been imported into scope and that Graphs.jl is imported:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"using GraphsMatching\nimport Graphs","category":"page"},{"location":"#GraphsMatching.MatchingResult","page":"Getting started","title":"GraphsMatching.MatchingResult","text":"struct MatchingResult{U}\n    weight::U\n    mate::Vector{Int}\nend\n\nA type representing the result of a matching algorithm.\n\nweight: total weight of the matching\n\nmate:    `mate[i] = j` if vertex `i` is matched to vertex `j`.\n         `mate[i] = -1` for unmatched vertices.\n\n\n\n\n\n","category":"type"},{"location":"#GraphsMatching.dict_to_arr-Union{Tuple{E}, Tuple{U}, Tuple{Int64, JuMP.Containers.DenseAxisArray{U, 1, Tuple{Vector{E}}, L} where L<:Tuple{JuMP.Containers._AxisLookup}, AbstractVector{E}}} where {U<:Real, E<:Graphs.SimpleGraphs.SimpleEdge}","page":"Getting started","title":"GraphsMatching.dict_to_arr","text":"Returns an array of mates from a dictionary that maps edges to {0,1} \n\n\n\n\n\n","category":"method"},{"location":"#GraphsMatching.maximum_weight_matching","page":"Getting started","title":"GraphsMatching.maximum_weight_matching","text":"maximumweightmatching(g::Graph, w::Dict{Edge,Real} -> Dict{Edge,Int64}\n\nGiven a graph g and an edgemap w containing weights associated to edges, returns a matching with the maximum total weight. w is a dictionary that maps edges i => j to weights. If no weight parameter is given, all edges will be considered to have weight 1 (results in max cardinality matching)\n\nThe efficiency of the algorithm depends on the input graph:\n\nIf the graph is bipartite, then the LP relaxation is integral.\nIf the graph is not bipartite, then it requires a MIP solver and\n\nthe computation time may grow exponentially.\n\nThe package JuMP.jl and one of its supported solvers is required.\n\nReturns MatchingResult containing:\n\na solve status (indicating whether the problem was solved to optimality)\nthe optimal cost\na list of each vertex's match (or -1 for unmatched vertices)\n\n\n\n\n\n","category":"function"},{"location":"#GraphsMatching.maximum_weight_matching_reduction-Union{Tuple{Graphs.SimpleGraphs.SimpleGraph}, Tuple{U}, Tuple{Graphs.SimpleGraphs.SimpleGraph, AbstractMatrix{U}}} where U<:Real","page":"Getting started","title":"GraphsMatching.maximum_weight_matching_reduction","text":"maximumweightmatching_reduction(g::Graph, w::Matrix{Real}) -> Array{Edge}\n\nGiven a graph g and an edgemap w containing weights associated to edges, returns a matching with the maximum total weight. w is an adjacent matrix that maps edges i => j to weights. If no weight parameter is given, all edges will be considered to have weight 1\n\nThis algorithm uses a reduction based on the minimumweightperfect_matching function  to find the maximum weight matching (see https://homepages.cwi.nl/~schaefer/ftp/pdf/masters-thesis.pdf section 1.5.1).\n\nReturn an array of edges contained in the matching.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#GraphsMatching.AbstractMinimumWeightPerfectMatchingAlgorithm","page":"Internals","title":"GraphsMatching.AbstractMinimumWeightPerfectMatchingAlgorithm","text":"AbstractMinimumWeightPerfectMatchingAlgorithm\n\nAbstract type that allows users to pass in their preferred algorithm\n\nSee also: minimum_weight_perfect_matching, BlossomVAlgorithm\n\n\n\n\n\n","category":"type"},{"location":"internals/#GraphsMatching.AbstractMaximumWeightMaximalMatchingAlgorithm","page":"Internals","title":"GraphsMatching.AbstractMaximumWeightMaximalMatchingAlgorithm","text":"AbstractMaximumWeightMaximalMatchingAlgorithm\n\nAbstract type that allows users to pass in their preferred algorithm\n\n\n\n\n\n","category":"type"},{"location":"internals/#GraphsMatching.cutoff_weights","page":"Internals","title":"GraphsMatching.cutoff_weights","text":"cutoff_weights copies the weight matrix with all elements below cutoff set to 0\n\n\n\n\n\n","category":"function"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/#GraphsMatching.minimum_weight_perfect_matching","page":"API","title":"GraphsMatching.minimum_weight_perfect_matching","text":"minimum_weight_perfect_matching(g, w::Dict{Edge,Real}; tmaxscale)\nminimum_weight_perfect_matching(g, w::Dict{Edge,Real}, cutoff; tmaxscale)\nminimum_weight_perfect_matching(g, w::Dict{Edge,Real}, algorithm::AbstractMinimumWeightPerfectMatchingAlgorithm; tmaxscale)\nminimum_weight_perfect_matching(g, w::Dict{Edge,Real}, cutoff, algorithm::AbstractMinimumWeightPerfectMatchingAlgorithm; tmaxscale)\n\nGiven a graph g and an edgemap w containing weights associated to edges, returns a matching with the mimimum total weight among the ones containing exactly nv(g)/2 edges.\n\nEdges in g not present in w will not be considered for the matching.\n\nYou can use the algorithm argument to specify the algorithm to use.\n\nA cutoff argument can be given, to reduce the computational time by excluding edges with weights higher than the cutoff (effective only for some algorithms, not for the default LEMONMWPMAlgorithm).\n\nWhen the weights are non-integer types, the keyword argument tmaxscale can be used to scale the weights to integer values. In case of error try to change tmaxscale (default is tmaxscale=10). The scaling is as follows:\n\ntmax = typemax(Int32) / tmaxscale\nweight = round(Int32, (weight-minimum_weight) / max(maximum_weight-minimum_weight, 1) * tmax)\n\nThe returned object is of type MatchingResult.\n\nSee also: BlossomVAlgorithm\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphsMatching.maximum_weight_maximal_matching","page":"API","title":"GraphsMatching.maximum_weight_maximal_matching","text":"maximum_weight_maximal_matching{T<:Real}(g, w::Dict{Edge,T})\n\nGiven a bipartite graph g and an edge map w containing weights associated to edges, returns a matching with the maximum total weight among the ones containing the greatest number of edges.\n\nEdges in g not present in w will not be considered for the matching.\n\nA cutoff keyword argument can be given, to reduce computational times excluding edges with weights lower than the cutoff.\n\nFinally, a specific algorithm can be chosen (algorithm keyword argument); each algorithm has specific dependencies. For instance:\n\nIf algorithm=HungarianAlgorithm() (the default), the package Hungarian.jl is used. This algorithm is always polynomial in time, with complexity O(nÂ³).\nIf algorithm=LPAlgorithm(), the package JuMP.jl and one of its supported solvers is required. In this case, the algorithm relies on a linear relaxation on of the matching problem, which is guaranteed to have integer solution on bipartite graphs. A solver must be provided with the optimizer keyword parameter.\n\nThe returned object is of type MatchingResult.\n\n\n\n\n\n","category":"function"},{"location":"API/#GraphsMatching.LEMONMWPMAlgorithm","page":"API","title":"GraphsMatching.LEMONMWPMAlgorithm","text":"LEMONMWPMAlgorithm()\n\nUse the LEMON C++ implementation of minimum weight perfect matching.\n\nSee also: minimum_weight_perfect_matching, BlossomVAlgorithm\n\n\n\n\n\n","category":"type"},{"location":"API/#GraphsMatching.LPAlgorithm","page":"API","title":"GraphsMatching.LPAlgorithm","text":"LPAlgorithm <: AbstractMaximumWeightMaximalMatchingAlgorithm\n\nForces the maximumweightmaximal_matching function to use a linear programming formulation.\n\n\n\n\n\n","category":"type"},{"location":"API/#GraphsMatching.HungarianAlgorithm","page":"API","title":"GraphsMatching.HungarianAlgorithm","text":"HungarianAlgorithm <: AbstractMaximumWeightMaximalMatchingAlgorithm\n\nForces the maximumweightmaximal_matching function to use the Hungarian algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API/#GraphsMatching.BlossomVAlgorithm","page":"API","title":"GraphsMatching.BlossomVAlgorithm","text":"BlossomVAlgorithm()\n\nUse the BlossomV algorithm to find the minimum weight perfect matching. Depends on the BlossomV.jl package. You have to call using BlossomV before using this algorithm.\n\nThis algorithm dispatches to the BlossomV library, a C library for finding minimum weight perfect matchings in general graphs. The BlossomV library is not open source, and thus we can not distribute a a precompiled binary with GraphsMatching.jl. We attempt to build it on installation, but unlike typical Julia packages, the build process is prone to failure if you do not have all the dependencies installed. If BlossomV.jl does not work on your system, consider using the LEMONGraphs.jl algorithm instead (the default algorithm), which we distribute precompiled on all platforms.\n\nSee also: minimum_weight_perfect_matching, LEMONMWPMAlgorithm\n\n\n\n\n\n","category":"type"}]
}
